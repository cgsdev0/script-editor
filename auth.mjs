import Database from "better-sqlite3";
import { randomBytes } from "crypto";
import { mkdirSync, existsSync } from "fs";
import { dirname } from "path";

export function initDb(dbPath) {
  const dir = dirname(dbPath);
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });

  const db = new Database(dbPath);
  db.pragma("journal_mode = WAL");

  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      twitch_id TEXT UNIQUE NOT NULL,
      username TEXT NOT NULL,
      display_name TEXT,
      avatar_url TEXT,
      created_at TEXT DEFAULT (datetime('now')),
      last_login TEXT DEFAULT (datetime('now'))
    );

    CREATE TABLE IF NOT EXISTS sessions (
      id TEXT PRIMARY KEY,
      user_id INTEGER NOT NULL REFERENCES users(id),
      created_at TEXT DEFAULT (datetime('now')),
      expires_at TEXT NOT NULL
    );

    CREATE TABLE IF NOT EXISTS document_permissions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      document_id TEXT NOT NULL,
      user_id INTEGER NOT NULL REFERENCES users(id),
      created_at TEXT DEFAULT (datetime('now')),
      UNIQUE(document_id, user_id)
    );

    CREATE TABLE IF NOT EXISTS document_owners (
      document_id TEXT PRIMARY KEY,
      user_id INTEGER NOT NULL REFERENCES users(id),
      created_at TEXT DEFAULT (datetime('now'))
    );

    CREATE TABLE IF NOT EXISTS document_versions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      document_id TEXT NOT NULL,
      user_id INTEGER REFERENCES users(id),
      created_at TEXT DEFAULT (datetime('now')),
      content TEXT NOT NULL,
      label TEXT,
      auto_generated INTEGER DEFAULT 1
    );
    CREATE INDEX IF NOT EXISTS idx_doc_versions_lookup
      ON document_versions(document_id, created_at DESC);
  `);

  return db;
}

export function upsertUser(db, { twitchId, username, displayName, avatarUrl }) {
  const stmt = db.prepare(`
    INSERT INTO users (twitch_id, username, display_name, avatar_url, last_login)
    VALUES (?, ?, ?, ?, datetime('now'))
    ON CONFLICT(twitch_id) DO UPDATE SET
      username = excluded.username,
      display_name = excluded.display_name,
      avatar_url = excluded.avatar_url,
      last_login = datetime('now')
  `);
  stmt.run(twitchId, username, displayName, avatarUrl);
  return db.prepare("SELECT * FROM users WHERE twitch_id = ?").get(twitchId);
}

export function createSession(db, userId) {
  const id = randomBytes(32).toString("hex");
  const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString();
  db.prepare("INSERT INTO sessions (id, user_id, expires_at) VALUES (?, ?, ?)").run(id, userId, expires);
  return id;
}

export function getSession(db, sessionId) {
  if (!sessionId) return null;
  const row = db.prepare(`
    SELECT s.id as session_id, s.expires_at, u.*
    FROM sessions s
    JOIN users u ON u.id = s.user_id
    WHERE s.id = ?
  `).get(sessionId);
  if (!row) return null;
  if (new Date(row.expires_at) < new Date()) {
    db.prepare("DELETE FROM sessions WHERE id = ?").run(sessionId);
    return null;
  }
  return {
    user: {
      id: row.id,
      twitchId: row.twitch_id,
      username: row.username,
      displayName: row.display_name,
      avatarUrl: row.avatar_url,
    },
  };
}

export function deleteSession(db, sessionId) {
  if (!sessionId) return;
  db.prepare("DELETE FROM sessions WHERE id = ?").run(sessionId);
}

export function parseSessionCookie(cookieHeader) {
  if (!cookieHeader) return null;
  const match = cookieHeader.match(/(?:^|;\s*)session=([^;]+)/);
  return match ? match[1] : null;
}

export function getDocumentPermissions(db, documentId) {
  return db.prepare(`
    SELECT dp.id, dp.document_id, dp.user_id, u.username, u.display_name, u.avatar_url
    FROM document_permissions dp
    JOIN users u ON u.id = dp.user_id
    WHERE dp.document_id = ?
  `).all(documentId);
}

export function grantDocumentAccess(db, documentId, userId) {
  db.prepare("INSERT OR IGNORE INTO document_permissions (document_id, user_id) VALUES (?, ?)").run(documentId, userId);
}

export function revokeDocumentAccess(db, documentId, userId) {
  db.prepare("DELETE FROM document_permissions WHERE document_id = ? AND user_id = ?").run(documentId, userId);
}

export function userCanEditDocument(db, documentId, userId) {
  const row = db.prepare("SELECT 1 FROM document_permissions WHERE document_id = ? AND user_id = ?").get(documentId, userId);
  return !!row;
}

export function findUserByUsername(db, username) {
  return db.prepare("SELECT * FROM users WHERE LOWER(username) = LOWER(?)").get(username) || null;
}

export function getAllUsers(db) {
  return db.prepare("SELECT id, username, display_name, avatar_url FROM users ORDER BY LOWER(username)").all();
}

export function createDocumentVersion(db, documentId, userId, content, label = null, autoGenerated = true) {
  const stmt = db.prepare(`
    INSERT INTO document_versions (document_id, user_id, content, label, auto_generated)
    VALUES (?, ?, ?, ?, ?)
  `);
  const result = stmt.run(documentId, userId, content, label, autoGenerated ? 1 : 0);
  return result.lastInsertRowid;
}

export function listDocumentVersions(db, documentId, limit = 50, offset = 0) {
  return db.prepare(`
    SELECT dv.id, dv.document_id, dv.user_id, dv.created_at, dv.label, dv.auto_generated,
           u.username, u.display_name, u.avatar_url
    FROM document_versions dv
    LEFT JOIN users u ON u.id = dv.user_id
    WHERE dv.document_id = ?
    ORDER BY dv.created_at DESC
    LIMIT ? OFFSET ?
  `).all(documentId, limit, offset);
}

export function getDocumentVersion(db, versionId) {
  return db.prepare(`
    SELECT dv.id, dv.document_id, dv.user_id, dv.created_at, dv.content, dv.label, dv.auto_generated,
           u.username, u.display_name, u.avatar_url
    FROM document_versions dv
    LEFT JOIN users u ON u.id = dv.user_id
    WHERE dv.id = ?
  `).get(versionId);
}

export function setDocumentOwner(db, documentId, userId) {
  db.prepare("INSERT OR IGNORE INTO document_owners (document_id, user_id) VALUES (?, ?)").run(documentId, userId);
}

export function getDocumentOwner(db, documentId) {
  return db.prepare(`
    SELECT u.id, u.twitch_id, u.username, u.display_name, u.avatar_url
    FROM document_owners do_
    JOIN users u ON u.id = do_.user_id
    WHERE do_.document_id = ?
  `).get(documentId) || null;
}

export function isDocumentOwner(db, documentId, userId) {
  const row = db.prepare("SELECT 1 FROM document_owners WHERE document_id = ? AND user_id = ?").get(documentId, userId);
  return !!row;
}

export function getOwnedDocumentIds(db, userId) {
  const rows = db.prepare("SELECT document_id FROM document_owners WHERE user_id = ?").all(userId);
  return new Set(rows.map(r => r.document_id));
}

export function deleteDocumentData(db, documentId) {
  db.prepare("DELETE FROM document_permissions WHERE document_id = ?").run(documentId);
  db.prepare("DELETE FROM document_versions WHERE document_id = ?").run(documentId);
  db.prepare("DELETE FROM document_owners WHERE document_id = ?").run(documentId);
}

export function deleteOldAutoVersions(db, documentId, keepCount = 200) {
  db.prepare(`
    DELETE FROM document_versions
    WHERE document_id = ? AND auto_generated = 1 AND id NOT IN (
      SELECT id FROM document_versions
      WHERE document_id = ? AND auto_generated = 1
      ORDER BY created_at DESC
      LIMIT ?
    )
  `).run(documentId, documentId, keepCount);
}
